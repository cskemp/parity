---
title: "Analyses of the parity of category systems"
output: html_document
---

Plots and analyses for Kemp, Category systems across languages reflect a preference for symmetry. Running this entire notebook takes around two hours -- in particular the regression analyses for kinship are relatively slow.

```{r setup}
knitr::opts_chunk$set(echo = TRUE)
library(lingtypology)
library(here)
library(tidyverse)
library(patchwork)
library(wcs)
library(glmmTMB)
library(kableExtra)
library(scales)
library(boot)
library(brms)
library(testthat)
library(xtable)
source(here("analysis", "generate_phylogenies.R"))

mytheme <-  theme_classic(base_size = 10)  +
            theme(strip.background = element_blank()) 

odd_even_cols <- c("#619CFF", "#F8766D")
yes_no_cols <- c("#AAAAAA", "#444444")

kinship_classes <- c("siblings", "parent's siblings", "grandparents", "grandchildren", "nieces+nephews", "cousins")

# treat these cases as unique when including langfamily as random effect
uniques <- c("", "Bookkeeping", "Mixed Language", "Pidgin", "Sign Language", "Speech register",  "Unattested", "Unclassifiable")

# load Glottolog, which will be used to specify language families for mixed models
gl <- glottolog %>% 
  select(language, glottocode, iso, area, affiliation, longitude, latitude) %>% 
  # remove initial parentheses 
  mutate(glottolog_langname= str_replace(language, " \\(.*\\)", "")) %>% 
  mutate(langfamily=affiliation) %>% 
  mutate(langfamily_split= str_split(affiliation, ", ")) %>% 
  mutate(langfamily = map_chr(langfamily_split, 1)) %>% 
  mutate(rownum = row_number()) %>% 
  mutate(langfamily = if_else(langfamily %in% uniques, paste0(langfamily, rownum), langfamily)) %>% 
  select(-language, -langfamily_split, -rownum) 

parity_levels <- c("odd", "even")
```

## Regression functions

Set up functions for running regression analyses. `run_phylo()` runs the phylogenetic regressions reported in the main text, and `run_glmmTMB() ` runs the frequentist regressions reported in the supplementary material. As a robustness check we also used `run_brms()` to run Bayesian mixed-effects regressions with a random effect for language family that are not reported in the paper.

```{r run_regression}
# function for frequentist regression analysis (using glmmTMB)
run_glmmTMB <- function(dstats, domainname) {
  rtype <- "langfamily"
  dstats <- dstats  %>% 
   mutate(parity = factor(parity, levels = parity_levels)) 
 
  if (domainname %in% paste0("m_", kinship_classes)) {
     rtype <- "--"
     m0 <- glm(parity ~ 0,  data = dstats, family = "binomial", weights = count)
     m1 <- glm(parity ~ 1,  data = dstats, family = "binomial", weights = count)
     coef <- m1$coefficients[1]
     m1conf <- confint(m1)
     lb <- m1conf[1]
     ub <- m1conf[2]
     a <- anova(m1, m0, test = "Chisq")
     pval <- a$`Pr(>Chi)`[2]
  } else if (domainname %in% c("locational (cardinal)") ) {
     rtype <- "--"
     m0 <- glm(parity ~ 0,  data = dstats, family = "binomial")
     m1 <- glm(parity ~ 1,  data = dstats, family = "binomial")
     coef <- m1$coefficients[1]
     m1conf <- confint(m1)
     lb <- m1conf[1]
     ub <- m1conf[2]
     a <- anova(m1, m0, test = "Chisq")
     pval <- a$`Pr(>Chi)`[2]
  } else  {
     lang_count <- dstats %>% 
        group_by(glottocode) %>% 
        mutate(n = n())
     max_lang <- max(lang_count$n) 
     if (domainname %in% c("locational (other)")) {
       rtype <- "lang"
       m0 <- glmmTMB(parity ~ 0 + offset(rep(0, nrow(dstats))) + (1|glottocode),  data = dstats, family = "binomial")
       m1 <- glmmTMB(parity ~ 1 + (1|glottocode), data = dstats, family = "binomial")
     } else if (max_lang == 1) {
      m0 <- glmmTMB(parity ~ 0 + offset(rep(0, nrow(dstats))) + (1|langfamily),  data = dstats, family = "binomial")
      m1 <- glmmTMB(parity ~ 1 + (1|langfamily), data = dstats, family = "binomial")
    } else {
      rtype <- "lang/langfamily"
      m0 <- glmmTMB(parity ~ 0 + offset(rep(0, nrow(dstats))) + (1|glottocode) + (1|langfamily),  data = dstats, family = "binomial")
      m1 <- glmmTMB(parity ~ 1 + (1|glottocode) + (1|langfamily), data = dstats, family = "binomial")
    }
    coef <- fixef(m1)$cond["(Intercept)"]
    m1conf <- confint(m1)
    lb <- m1conf[1,1]
    ub <- m1conf[1,2]
    
    a <- anova(m1, m0)
    pval <- a$`Pr(>Chisq)`[2]
  }
  
  
  if (domainname %in% paste0("m_", kinship_classes)) {
    nlang <- sum(dstats$count)
    nsys <- nlang
  } else { 
    nlang <- length(unique(dstats$glottocode))
    nsys <- nrow(dstats)
  }
  
  summ <- tibble(
    domain = domainname,
    coefficient = coef,
    p_val = pval,
    lb = lb,
    ub = ub,
    type = rtype,
    nlang = nlang,
    nsys = nsys
  )  
}

quiet_brm <- quietly(brm)


# function for Bayesian mixed-effects regression analysis (using brms)
run_brms <- function(dstats, domainname) {
  #return()
  lang_count <- dstats %>%
    group_by(glottocode) %>%
    mutate(n = n()) %>%
    ungroup() 

  max_lang <- if (nrow(lang_count) > 0) max(lang_count$n) else 0

  nchain <- 4
  niter <- 3000 
  b_con <- list(adapt_delta = 0.95)
  if (domainname %in% c("siblings", "grandchildren", "nieces+nephews", "parent's siblings", "spatial demonstratives (distance)")) {
    niter <- 8000
    b_con <- list(adapt_delta = 0.98)
  }
  if (domainname %in% c("grandparents")) {
    niter <- 8000
    b_con <- list(adapt_delta = 0.99)
  } 
  if (domainname %in% c("cousins")) {
    niter <- 6000
    b_con <- list(adapt_delta = 0.95)
  }
  
  dstats <- dstats %>%
    mutate(parity = parity == "even")

  # Determine model formula based on domainname and data structure
  if (domainname == "locational (cardinal)") {
    rtype <- "--"
    formula <- bf(parity ~ 1)
  } else if (domainname == "locational (other)") {
    rtype <- "lang"
    formula <- bf(parity ~ (1 | glottocode))
  } else if (max_lang == 1) {
    rtype <- "langfamily"
    formula <- bf(parity ~ 1 + (1 | langfamily))
  } else {
    rtype <- "lang/langfamily"
    formula <- bf(parity ~ 1 + (1 | glottocode) + (1 | langfamily))
  }

  m1 <-  quiet_brm( formula = formula, data = dstats, family = bernoulli(), chains = nchain, iter = niter, control = b_con, seed = 1  )
  
  brms_tab <- fixef(m1$result) %>%
    as_tibble(rownames = "term") 

  # Ensure intercept term exists before extracting values
  intercept_row <- brms_tab %>% filter(term == "Intercept")

  # Create the summary tibble including warnings
  summ <- tibble(
    domain = domainname,
    coefficient = if(nrow(intercept_row) > 0) intercept_row$Estimate else NA_real_,
    lb = if(nrow(intercept_row) > 0) intercept_row$Q2.5 else NA_real_,
    ub = if(nrow(intercept_row) > 0) intercept_row$Q97.5 else NA_real_,
    type = rtype,
    nlang = length(unique(dstats$glottocode)),
    nsys = nrow(dstats),
    warnings = paste(m1$warnings, collapse = " | ")
  )
  return(summ)
}

# function for phylogenetic regression analysis (also uses brms)
run_phylo <- function(dstats, domainname) {
  #return()
  phylogeny <- make_phylogeny(dstats, domainname) 
  
  # Calculate covariance matrix. We follow GuzmÃ¡n Naranjo and Becker and set corr = TRUE, 
  # although the brms vignette uses a covariance matrix instead (corr = FALSE)
  A <- ape::vcv.phylo(phylogeny, corr = TRUE)

  # --- Initial data setup ---
  lang_count <- dstats %>%
    group_by(glottocode) %>%
    mutate(n = n()) %>%
    ungroup() 

  max_lang <- if (nrow(lang_count) > 0) max(lang_count$n) else 0

  nchain <- 4
  niter <- 3000 
  b_con <- list(adapt_delta = 0.95)
  
  if (domainname %in% c("siblings", "nieces+nephews", "cousins")) {
    niter <- 10000
  } else if (domainname %in% c("parent's siblings", "grandparents", "grandchildren", "spatial demonstratives (orientation)")) {
    niter <- 10000 
    b_con <- list(adapt_delta = 0.99)
  } else if (domainname %in% c("tense")) {
    niter <- 10000
  } else if (domainname %in% c("deictic day names")) {
    niter <- 6000 
    b_con <- list(adapt_delta = 0.98)
  }

  dstats <- dstats %>%
    mutate(parity = parity == "even") %>% 
    mutate(glottocode_dup = glottocode)

  rtype <- "--" # Default value
  formula <- NULL
  data2_arg <- NULL
  fit_model <- TRUE # Flag to control if model should be fitted

  if (domainname == "locational (cardinal)") {
    rtype <- "--"
    formula <- bf(parity ~ 1)
  } else if (domainname == "locational (other)") {
    rtype <- "lang"
    formula <- bf(parity ~ (1 | glottocode))
  } else if (max_lang == 1) {
    rtype <- "phylo_langfamily" 
    # Using phylogenetic random effect for glottocode
    formula <- bf(parity ~ 1 + (1 | gr(glottocode, cov = A)))
    data2_arg <- list(A = A)
  } else {
    # Multiple rows per glottocode -- following the example here
    # https://cran.r-project.org/web/packages/brms/vignettes/brms_phylogenetics.html
    # that includes multiple observations per species
    rtype <- "phylo_lang/langfamily" 
    formula <- bf(parity ~ 1 + (1|glottocode_dup) + (1 | gr(glottocode, cov = A))) 
    data2_arg <- list(A = A)
  }
  m1 <- quiet_brm( 
          formula = formula,
          data = dstats,
          data2 = data2_arg, # Will be NULL if not set above
          family = bernoulli(),
          chains = nchain,
          iter = niter,
          control = b_con,
          seed = 1
      )
     
   brms_tab <- 
       fixef(m1$result) %>%
       as_tibble(rownames = "term") 
   
  # Ensure intercept term exists before extracting values
  intercept_row <- brms_tab %>% filter(term == "Intercept")

  # Create the summary tibble including warnings
  summ <- tibble(
    domain = domainname,
    coefficient = if(nrow(intercept_row) > 0) intercept_row$Estimate else NA_real_,
    lb = if(nrow(intercept_row) > 0) intercept_row$Q2.5 else NA_real_,
    ub = if(nrow(intercept_row) > 0) intercept_row$Q97.5 else NA_real_,
    type = rtype,
    nlang = length(unique(dstats$glottocode)),
    nsys = nrow(dstats),
    warnings = paste(m1$warnings, collapse = " | ")
  )
  return(summ)
}

# run regression analysis for multiple subdomains
run_regression_group <- function(dstats_group, regression_function) {
 dstats_all <- dstats_group %>% 
   group_by(domain) %>% 
   nest() %>% 
   ungroup()
  
  summ <- dstats_all %>% 
    mutate(result = map2(data, domain, regression_function)) %>% 
    select(-domain, -data) %>% 
    unnest(cols = c(result))
}
```

Also define some other utility functions.

```{r other_utility, cache=TRUE}

# count systems of different sizes
make_counts <- function(d) {
  d %>% 
    group_by(size) %>% 
    summarize(count = n(), .groups = "drop") %>% 
    mutate(parity = factor(size %% 2, label= c("even", "odd")))
}

# plot distribution on sizes
plot_sizes <- function(counts, parity_counts, ylabel) {
   counts <- counts %>%  
     mutate(parity = factor(parity, levels = parity_levels))
   
   parity_counts <- parity_counts %>%  
     mutate(parity = factor(parity, levels = parity_levels))
  
  # decided not to show systems of size 0 in plot, because they don't contribute to the overall even count. 
  
  size_plot <- counts %>% 
    ggplot(aes(x=size, y = count, fill=parity, color=parity)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = c("odd" = odd_even_cols[1], "even" = odd_even_cols[2]), drop = FALSE) +
    scale_color_manual(values = c("odd" = odd_even_cols[1], "even" = odd_even_cols[2]), drop = FALSE) +
    ylab('system count') + 
    mytheme +
    theme(legend.position = "none") 
  
  parity_plot <- parity_counts %>% 
    ggplot(aes(x=parity, y = count, fill=parity, color=parity)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = c("odd" = odd_even_cols[1], "even" = odd_even_cols[2]), drop = FALSE) +
    scale_color_manual(values = c("odd" = odd_even_cols[1], "even" = odd_even_cols[2]), drop = FALSE) +
    ylab('system count') + 
    mytheme +
    theme(legend.position = "none")
  
  double_plot <- size_plot + parity_plot +
    plot_layout(widths = c(2,1)) +
    plot_annotation(tag_levels = c('a'), tag_suffix = ')')
} 

# plot distribution of sizes for multiple subdomains (here called classes)
plot_sizes_class <- function(counts, parity_counts) {
  counts <- counts %>%  
    mutate(parity = factor(parity, levels = parity_levels))
   
  parity_counts <- parity_counts %>%  
    mutate(parity = factor(parity, levels = parity_levels))
  
  size_plot <- counts %>% 
    ggplot(aes(x=size, y = count, fill=parity, color=parity)) +
    geom_bar(stat = "identity") +
    theme(legend.position = "none") +
    facet_wrap(~class, scales = "free_y")
  
  parity_plot <- parity_counts %>% 
    ggplot(aes(x=parity, y = count, fill=parity, color=parity)) +
    geom_bar(stat = "identity") +
    theme(legend.position = "none") +
    facet_wrap(~class, scales = "free_y")
  
  double_plot <- size_plot +  parity_plot +
    plot_layout(widths = c(2,1))
} 

```

Now run the analyses for each domain in turn.

## Deictic day naming and Tense

```{r temporal, cache=TRUE}
tense_data <- read_csv(here("data", "velupillai_tense_data.csv")) %>% 
  rename(size = complexity)
deictic_data <- read_csv(here("data", "tent_deictic_systems.csv")) %>% 
  rename(size = complexity)

# drop systems with no tense marking
tense_counts <- make_counts(tense_data) %>% 
  filter(size > 0) %>% 
  mutate(domain = "tense")
  
deictic_counts <- make_counts(deictic_data) %>% mutate(domain = "deictic day names")

all_counts <- bind_rows(deictic_counts, tense_counts)

tense_parity_counts <- tense_counts %>% 
  filter(size > 0) %>% 
  group_by(parity) %>% 
  summarize(count = sum(count), .groups = "drop") %>% 
  mutate(domain = "tense")

deictic_parity_counts <- deictic_counts %>% 
  group_by(parity) %>% 
  summarize(count = sum(count), .groups = "drop") %>% 
  mutate(domain = "deictic day names")

all_parity_counts <- bind_rows(deictic_parity_counts, tense_parity_counts)

tense_stats_data <- tense_data %>% 
  select(gcode, family, size) %>% 
  rename(glottocode = gcode) %>% 
  mutate(rn = row_number()) %>% 
  mutate(family = if_else(family == "Unclassified", paste0(family, rn), family)) %>% 
  select(-rn) %>% 
  filter(size > 0) %>% 
  mutate(parity = factor(size %% 2, label= c("even", "odd"))) %>% 
  left_join(gl, by = "glottocode")

deictic_stats_data <- deictic_data  %>% 
  select(gcode, phylum_family, size) %>% 
  rename(family = phylum_family) %>% 
  mutate(rn = row_number()) %>% 
  mutate(family = if_else(family %in% c("ARTIFICIAL", "ISOLATE", "PIDGINS & CREOLES"), paste0(family, rn), family)) %>% 
  select(-rn) %>% 
  mutate(parity = factor(size %% 2, label= c("even", "odd"))) %>% 
  rename(glottocode = gcode) %>% 
  left_join(gl, by = "glottocode")
    
tense_plot <- plot_sizes(tense_counts, tense_parity_counts, 'Tense system count') 
deictic_plot <- plot_sizes(deictic_counts, deictic_parity_counts, 'Temporal deictic system count') 
show(tense_plot)
show(deictic_plot)

deictic_results <- run_glmmTMB(deictic_stats_data, "deictic day names") 
deictic_results_bayes <- run_brms(deictic_stats_data %>% filter(!is.na(glottocode)), "deictic day names") 
deictic_results_phylo <- run_phylo(deictic_stats_data %>% filter(!is.na(glottocode)), "deictic day names") 

tense_results <- run_glmmTMB(tense_stats_data, "tense") 
tense_results_bayes <- run_brms(tense_stats_data, "tense") 
tense_results_phylo <- run_phylo(tense_stats_data, "tense")

all_results <- bind_rows(deictic_results, tense_results)
all_results_bayes <- bind_rows(deictic_results_bayes, tense_results_bayes)
all_results_phylo <- bind_rows(deictic_results_phylo, tense_results_phylo)
```         

## Seasons

```{r seasons, cache = TRUE}   
# drop systems with no seasons
seasons_data <- read_csv(here("data", "kemp_seasons.csv")) %>% 
  filter(size > 0) 

seasons_counts <- make_counts(seasons_data) %>% 
  mutate(domain = "seasons")

seasons_parity_counts <- seasons_counts %>% 
  filter(size > 0) %>% 
  group_by(parity) %>% 
  summarize(count = sum(count), .groups = "drop") %>% 
  mutate(domain = "seasons")

seasons_stats_data_orig <- seasons_data %>% 
  rename(glottocode = gcode) %>% 
  left_join(gl, by = "glottocode") %>% 
  select(glottocode, langname, size, langfamily) %>% 
  mutate(parity = factor(size %% 2, label= c("even", "odd"))) 
  
seasons_stats_lcount <- seasons_stats_data_orig %>% 
  group_by(glottocode) %>% 
  mutate(lcount = n())

seasons_mult <- seasons_stats_lcount %>% 
  filter(lcount > 1)
# we have a handful of languages with multiple systems. If all have the same parity ...
expect_equal(length(unique(seasons_mult$parity)), 1)
# it's safe to keep just the first of each 
seasons_stats_data <- seasons_stats_data_orig %>% 
    distinct(glottocode, .keep_all = TRUE)

seasons_plot <- plot_sizes(seasons_counts, seasons_parity_counts, 'Season system count')
show(seasons_plot)

seasons_results <- run_glmmTMB(seasons_stats_data, "seasons") 
seasons_results_bayes <- run_brms(seasons_stats_data, "seasons") 
seasons_results_phylo <- run_phylo(seasons_stats_data, "seasons")

all_counts <- bind_rows(all_counts, seasons_counts)
all_parity_counts <- bind_rows(all_parity_counts, seasons_parity_counts)
all_results <- bind_rows(all_results, seasons_results)
all_results_bayes <- bind_rows(all_results_bayes, seasons_results_bayes)
all_results_phylo <- bind_rows(all_results_phylo, seasons_results_phylo)
```

## Moon Phases

```{r moonphases, cache = TRUE}

moonphases_data <- read_csv(here("data", "kemp_moonphases.csv"))  %>% 
  filter(!is.na(gcode))

moonphases_counts <- make_counts(moonphases_data) %>% 
  mutate(domain = "moon phases")

moonphases_parity_counts <- moonphases_counts %>% 
  group_by(parity) %>% 
  summarize(count = sum(count), .groups = "drop") %>% 
  mutate(domain = "moon phases")

moonphases_plot <- plot_sizes(moonphases_counts, moonphases_parity_counts, 'Moon phases system count')
show(moonphases_plot)

moonphases_stats_data_orig <- moonphases_data %>% 
  rename(glottocode = gcode) %>% 
  left_join(gl, by = "glottocode") %>% 
  select(glottocode, size, langfamily) %>% 
  mutate(parity = factor(size %% 2, label= c("even", "odd"))) 

moonphases_stats_lcount <- moonphases_stats_data_orig %>% 
  group_by(glottocode) %>% 
  mutate(lcount = n())

moonphases_mult <- moonphases_stats_lcount %>% 
  filter(lcount > 1)

# we have a handful of languages with multiple systems. If all have the same parity ...
expect_equal(length(unique(moonphases_mult$parity)), 1)
# it's safe to keep just the first of each 
moonphases_stats_data <- moonphases_stats_data_orig %>% 
    distinct(glottocode, .keep_all = TRUE)
  
moonphases_results <- run_glmmTMB(moonphases_stats_data, "moon phases") 
moonphases_results_bayes <- run_brms(moonphases_stats_data, "moon phases") 
moonphases_results_phylo <- run_phylo(moonphases_stats_data, "moon phases")

all_counts <- bind_rows(all_counts, moonphases_counts)
all_parity_counts <- bind_rows(all_parity_counts, moonphases_parity_counts)
all_results <- bind_rows(all_results, moonphases_results)
all_results_bayes <- bind_rows(all_results_bayes, moonphases_results_bayes)
all_results_phylo <- bind_rows(all_results_phylo, moonphases_results_phylo)

```

## Locational systems
```{r locational, cache=TRUE}

# drop compass_relative (one language only), and all types involving vertical/topographic because they were especially hard to code

type_keep <-c("compass_absolute", "sun_only", "wind_only", "wind_and_climate", "climate_weather", "coast_and_wind", "coast_only", "sun_coast_and_river", "river_and_sun", "river_only", "tide", "spiritual_cultural_places_of_significance", "other")

locational_data <- read_csv(here("data", "ozspace_sizes.csv"))  %>% 
  rename(class=type)  %>% 
  filter(class %in% type_keep)

locational_counts <- locational_data %>% 
  group_by(class, size) %>% 
  summarize(count = n(), .groups = "drop") %>% 
  filter(size > 0) %>% 
  mutate(parity = factor(size %% 2, label= c("even", "odd"))) 

locational_parity_counts <- locational_counts %>% 
  group_by(parity, class) %>% 
  summarize(count = sum(count), .groups = "drop")
  
locational_plot <- plot_sizes_class(locational_counts, locational_parity_counts)
show(locational_plot)

locational_data_group <- locational_data  %>% 
  mutate(domain= if_else(class == "compass_absolute", "locational (cardinal)", "locational (other)"))
  
locational_counts_group <- locational_data_group %>% 
  group_by(domain, size) %>% 
  summarize(count = n(), .groups = "drop") %>% 
  filter(size > 0) %>% 
  mutate(parity = factor(size %% 2, label= c("even", "odd"))) 

locational_parity_counts_group <- locational_counts_group %>% 
  group_by(parity, domain) %>% 
  summarize(count = sum(count), .groups = "drop")

locational_stats_group_data_full <- locational_data_group %>% 
  select(iso, language, size, domain, gcode_manual) %>% 
  mutate(parity = factor(size %% 2, label= c("even", "odd"))) %>% 
  left_join(gl %>% select(iso, glottocode), by = "iso") %>% 
  select(-iso) %>% 
  mutate(glottocode = if_else(!is.na(gcode_manual), gcode_manual, glottocode)) %>% 
  left_join(gl, by = "glottocode") 

# include at most one cardinal system per glottocode 
locational_stats_group_data <- locational_stats_group_data_full %>% 
    # keep odd-numbered Wajarri cardinal system
    filter(!(language == "Wajarri" & domain == "locational (cardinal)") | size == 3)  %>% 
    mutate(rn = row_number()) %>% 
    mutate(rn = if_else(domain == "locational (cardinal)", 0, rn)) %>% 
    distinct(glottocode, rn, .keep_all = TRUE)

locational_results <- run_regression_group(locational_stats_group_data, run_glmmTMB)
locational_results_bayes <- run_regression_group(locational_stats_group_data, run_brms)
locational_results_phylo <- run_regression_group(locational_stats_group_data, run_phylo)

all_counts <- bind_rows(all_counts, locational_counts_group)
all_parity_counts <- bind_rows(all_parity_counts, locational_parity_counts_group)
all_results <- bind_rows(all_results, locational_results)
all_results_bayes <- bind_rows(all_results_bayes, locational_results_bayes)
all_results_phylo <- bind_rows(all_results_phylo, locational_results_phylo)
```

## Kinship

First we analyze the Murdock kinship data described in the supplementary material.

```{r kinship_murdock}

kinship_counts_murdock <- read_csv(here("data", "murdock_kinship.csv"))  %>% 
    mutate(
      class = case_match(
      class,
      "parent_siblings" ~ "parent's siblings",
      "nieces_nephews" ~ "nieces+nephews",
      .default = class 
    )
  ) %>% 
  mutate(parity = factor(size %% 2, label= c("even", "odd"))) %>% 
  mutate(domain= factor(class, levels = kinship_classes)) %>% 
  filter(size > 1) 

kinship_parity_counts_murdock <- kinship_counts_murdock %>% 
  group_by(parity, domain, class) %>% 
  summarize(count = sum(count), .groups = "drop")

show(plot_sizes_class(kinship_counts_murdock, kinship_parity_counts_murdock))

kinship_results_murdock <- run_regression_group(kinship_parity_counts_murdock %>% mutate(domain = paste0("m_", domain)), run_glmmTMB)

# we don't include Murdock results in main results table

#all_counts <- bind_rows(all_counts, kinship_counts %>% select(-class))
#all_parity_counts <- bind_rows(all_parity_counts, kinship_parity_counts %>% select(-class))
#all_results <- bind_rows(all_results, kinship_results)
```

Now analyze the Kinbank data reported in the main text.

```{r kinship_kinbank, cache = TRUE}
kinship_data <- read_csv(here("data", "kinbank_kinship.csv"))  %>% 
    mutate(
      class = case_match(
      class,
      "parent_siblings" ~ "parent's siblings",
      "nieces_nephews" ~ "nieces+nephews",
      .default = class 
      )
    ) %>% 
  mutate(domain= factor(class, levels = kinship_classes))  %>% 
  # still needed even though we didn't include concepts like mG and fG for sibling -- some systems (e.g. bann1247) list meB, myB, meZ, myZ, feB, fyB, feZ, fyZ, separately with the same form.
  filter(size > 1) 

kinship_counts <- kinship_data %>% 
  group_by(class, size) %>% 
  summarize(count = n(), .groups = "drop") %>% 
  mutate(parity = factor(size %% 2, label= c("even", "odd"))) 

kinship_parity_counts <- kinship_counts %>% 
  group_by(parity, class) %>% 
  summarize(count = sum(count), .groups = "drop")

show(plot_sizes_class(kinship_counts, kinship_parity_counts))

kinship_stats_data <- kinship_data %>% 
  left_join(gl, by = "glottocode") %>% 
  select(domain, glottocode, size, langfamily) %>% 
  mutate(parity = factor(size %% 2, label= c("even", "odd"))) 

kinship_results <- run_regression_group(kinship_stats_data, run_glmmTMB)
kinship_results_bayes <- run_regression_group(kinship_stats_data, run_brms)
kinship_results_phylo <- run_regression_group(kinship_stats_data, run_phylo)

all_counts <- bind_rows(all_counts, kinship_counts %>% rename(domain=class))
all_parity_counts <- bind_rows(all_parity_counts, kinship_parity_counts %>% rename(domain=class))
all_results <- bind_rows(all_results, kinship_results)
all_results_bayes <- bind_rows(all_results_bayes, kinship_results_bayes)
all_results_phylo <- bind_rows(all_results_phylo, kinship_results_phylo)
```


## Other domains 

Social classification systems

```{r social}
all_austkin <- c("sections", "subsections", "underspecified sections", "matri-moieties", "patri-moieties", "generational moieties", "matri-semi-moieties", "patri-semi-moieties", "phratries", "totems")

social_categories <- c("sections", "subsections", "underspecified sections", "matri-moieties", "patri-moieties", "generational moieties", "matri-semi-moieties", "patri-semi-moieties")

social_counts <- read_csv(here("data", "austkin_sizes.csv"))  %>% 
  rename(size=NumEntries, class=Category) %>% 
  filter(class %in% social_categories) %>% 
  group_by(ID, Name, Code) %>% 
  summarize(size = max(size), .groups = "drop") %>% 
  # manually fix one entry which seems wrong 
  mutate(size = if_else(Name == "Mayi-Kutuna", 4, size)) %>% 
  group_by(size) %>% 
  summarize(count = n(), .groups = "drop") %>% 
  mutate(parity = factor(size %% 2, label= c("even"))) %>% 
  filter(size > 0)  %>% 
  mutate(domain = "social categories")

social_parity_counts <- social_counts %>% 
  group_by(parity) %>% 
  summarize(count = sum(count), .groups = "drop")  %>% 
  mutate(domain = "social categories")

social_plot <- plot_sizes(social_counts, social_parity_counts, 'social system count')
show(social_plot)

all_counts <- bind_rows(all_counts, social_counts)
all_parity_counts <- bind_rows(all_parity_counts, social_parity_counts)
```

Color

```{r color, cache = TRUE}
modal_response <- term %>% 
  group_by(lang_nr, chip_nr, term_abb) %>% 
  summarize(count = n(), .groups = "drop_last") %>% 
  mutate(total = sum(count), ratio = count/total) %>% 
  filter(ratio >= 0.6)

color_data <- modal_response %>% 
  group_by(lang_nr) %>% 
  summarize(size = length(unique(term_abb)), .groups = "drop") %>% 
  left_join(lang, by = "lang_nr") %>% 
  rename(iso = "iso_693_3") %>% 
  # handle one case manually
  mutate(iso= if_else(lang_name== "Tarahumara (Western)", "tac", iso)) %>% 
  left_join(gl, by = "iso")  

color_counts <- make_counts(color_data) %>% 
  mutate(domain = "color")

color_parity_counts <- color_counts %>% 
  group_by(parity) %>% 
  summarize(count = sum(count), .groups = "drop") %>% 
  mutate(domain = "color")

color_stats_data <- color_data %>% 
  mutate(parity = factor(size %% 2, label= c("even", "odd")))  

color_results <- run_glmmTMB(color_stats_data, "color") 
color_results_bayes <- run_brms(color_stats_data, "color") 
color_results_phylo <- run_phylo(color_stats_data, "color")

color_plot <- plot_sizes(color_counts, color_parity_counts, 'color system count') 
show(color_plot)

all_counts <- bind_rows(all_counts, color_counts)
all_parity_counts <- bind_rows(all_parity_counts, color_parity_counts)
all_results <- bind_rows(all_results, color_results)
all_results_bayes <- bind_rows(all_results_bayes, color_results_bayes)
all_results_phylo <- bind_rows(all_results_phylo, color_results_phylo)
```

Lifeform terms

```{r lifeform, cache = TRUE}
lifeform_data <- read_csv(here("data", "brown_lifeforms.csv"))  

lifeform_counts <- make_counts(lifeform_data) %>% 
  mutate(domain = "life forms")

lifeform_parity_counts <- lifeform_counts %>% 
  filter(size > 0) %>% 
  group_by(parity) %>% 
  summarize(count = sum(count), .groups = "drop") %>% 
  mutate(domain = "life forms")

lifeform_stats_data <- lifeform_data %>% 
  left_join(gl, by = "glottocode") %>% 
  select(glottocode, langname, size, langfamily) %>% 
  mutate(parity = factor(size %% 2, label= c("even", "odd"))) 

lifeform_results <- run_glmmTMB(lifeform_stats_data, "life forms") 
lifeform_results_bayes <- run_brms(lifeform_stats_data, "life forms") 
lifeform_results_phylo <- run_phylo(lifeform_stats_data, "life forms")

lifeform_plot <- plot_sizes(lifeform_counts, lifeform_parity_counts, 'lifeform system count') 
show(lifeform_plot)

all_counts <- bind_rows(all_counts, lifeform_counts)
all_parity_counts <- bind_rows(all_parity_counts, lifeform_parity_counts)
all_results <- bind_rows(all_results, lifeform_results)
all_results_bayes <- bind_rows(all_results_bayes, lifeform_results_bayes)
all_results_phylo <- bind_rows(all_results_phylo, lifeform_results_phylo)
```

## Summary figures 

Make Figures 2 and 3.

```{r overall, fig.height = 6}
domain_order <- c("deictic day names", "tense", "seasons", "moon phases", "locational (cardinal)",  "siblings", "parent's siblings", "grandparents", "grandchildren", "nieces+nephews", "cousins", "social categories", "locational (other)", "color", "life forms")

all_counts <- all_counts %>% 
    mutate(domain = factor(domain, levels = domain_order)) %>% 
    mutate(parity = factor(parity, levels = parity_levels))
all_counts <- all_counts %>%  
    mutate(parity = factor(parity, levels = parity_levels)) %>% 
    mutate(domain = factor(domain, levels = domain_order))
   
all_parity_counts <- all_parity_counts %>%  
    mutate(parity = factor(parity, levels = parity_levels)) %>% 
    mutate(domain = factor(domain, levels = domain_order))
  
all_stats_data <- bind_rows(
  deictic_stats_data %>% mutate(domain = "deictic day names"),
  tense_stats_data %>% mutate(domain = "tense"),
  seasons_stats_data %>% mutate(domain = "seasons"),
  moonphases_stats_data %>% mutate(domain = "moon phases"),
  locational_stats_group_data, 
  kinship_stats_data ,
  color_stats_data %>% mutate(domain = "color"),
  lifeform_stats_data %>% mutate(domain = "life forms"),
) %>% 
  select(glottocode, domain) %>% 
  group_by(domain) %>% 
  summarize(n_stats = n(), .groups = "drop") %>% 
  bind_rows(tibble(domain = "social categories", n_stats = sum(social_counts$count)))

# make combined plot

create_panel <- function(df) {
    index <- df$panel_index[1]
    ylab = ""
    xlab1 = ""
    xlab2 = ""
    labelpad = "     "
    if (index %in% c(1,4,7,10,13)) {
      ylab = "count"
      labelpad = ""
    } 
    if (index %in% c(13,14,15)) {
      xlab1 = "size"
      xlab2 = "parity"
    } 
    
  panel_label <- paste0(labelpad, "(", letters[index], ")", " ", df$dom_label[1]) 
  size_dist <- ggplot(df, aes(x = size, y = count, fill=parity, color=parity)) +
    geom_bar(stat = "identity", width = 0.8) +
    scale_fill_manual(values = c("odd" = odd_even_cols[1], "even" = odd_even_cols[2])) +
    scale_color_manual(values = c("odd" = odd_even_cols[1], "even" = odd_even_cols[2])) +
    labs(x = xlab1, y = ylab) +
    mytheme  +
    theme(legend.position = "none")  +
    theme(plot.margin = margin(0, 0, 0, 0, "cm")) + 
    labs(title = panel_label) +
    theme(plot.title = element_text(hjust = 0, size = 10)) +
    theme(plot.title.position = "plot",  plot.caption.position =  "plot" ) + 
    scale_x_continuous(breaks = breaks_pretty())  +
    scale_y_continuous(breaks = pretty_breaks(4))
  
  
  even_odd_counts <- df %>%
    group_by(parity) %>%
    summarize(n = sum(count)) %>% 
    ggplot(aes(x = parity, y = n, fill = parity, color=parity)) +
    geom_bar(stat = "identity") +
    #theme(legend.position = "none") +
    labs(x = xlab2, y = "") +
    scale_fill_manual(values = c("odd" = odd_even_cols[1], "even" = odd_even_cols[2])) +
    scale_color_manual(values = c("odd" = odd_even_cols[1], "even" = odd_even_cols[2])) +
    scale_x_discrete(drop = FALSE, labels = c("O", "E"))  +
    mytheme +
    theme(axis.title.y=element_blank()) +
    theme(legend.position = "none")  +
    scale_y_continuous(breaks = pretty_breaks(2)) +
    theme(plot.margin = margin(0, 0, 0, 0, "cm")) 
  
  size_dist + even_odd_counts + plot_layout(widths = c(3, 1))  
}

# Create a list of panels
panels <- all_counts %>%
  mutate(panel_index = as.integer(domain)) %>% 
  mutate(dom_label = domain) %>% 
  group_by(domain) %>%
  group_map(~ create_panel(.x))

# Arrange the panels in a 3x5 grid using patchwork
final_plot <- wrap_plots(panels, nrow = 5, ncol = 3)

ggsave(here("output", "figures", "descriptive.pdf"), plot = final_plot, width = 7,height = 6)

show(final_plot)
```

```{r overall_continued, fig.height = 3}
# make similar plot for Murdock kinship data
panels_murdock <- kinship_counts_murdock %>%
  mutate(parity = factor(parity, levels = parity_levels)) %>% 
  mutate(panel_index = as.integer(domain)) %>% 
  mutate(dom_label = domain) %>% 
  group_by(domain) %>%
  group_map(~ create_panel(.x))

# Arrange the panels in a 3x5 grid using patchwork
final_plot_murdock <- wrap_plots(panels_murdock, nrow = 2, ncol = 3)

ggsave(here("output", "figures", "descriptive_murdock.pdf"), plot = final_plot_murdock, width = 7,height = 2.4)

show(final_plot_murdock)

# treat social categories as special case
all_means <- all_parity_counts %>% 
  group_by(domain) %>% 
  mutate(nsys = sum(count), coefficient = count/sum(count), lb = coefficient, ub = coefficient, p_val = 0) %>% 
  filter( parity == "even") %>% 
  select(domain, nsys, coefficient, p_val, lb, ub) %>% 
  filter( domain %in% c("social categories") ) 
  
logistic <- function(x) { 1/(1+exp(-x)) }

make_plot_results <- function(results, all_means) {
  all_results_transform <- results %>% 
    mutate(coefficient=logistic(coefficient), lb = logistic(lb), ub = logistic(ub) ) %>% 
    bind_rows(all_means) %>% 
    arrange(coefficient) %>% 
    mutate(predict_col = if_else(domain %in% c("tense", "deictic day names"), odd_even_cols[1], odd_even_cols[2])) %>% 
    mutate(predict_col = if_else(domain %in% c("color", "life forms"), "#808588", predict_col))
}

all_result_freq_forplot <- make_plot_results(all_results, all_means) %>% 
  left_join(all_stats_data) %>% 
  mutate(domain_label = paste0(domain, " (n = ", n_stats, ")" ))
all_result_bayes_forplot <- make_plot_results(all_results_bayes, all_means) %>% 
  left_join(all_stats_data) %>% 
  mutate(domain_label = paste0(domain, " (n = ", n_stats, ")" ))
all_result_phylo_forplot <- make_plot_results(all_results_phylo, all_means) %>% 
  left_join(all_stats_data) %>% 
  mutate(domain_label = paste0(domain, " (n = ", n_stats, ")" ))

plot_bayes <- all_result_bayes_forplot %>% 
  ggplot(aes(x=coefficient, fct_reorder(domain_label, coefficient))) + 
  geom_vline(xintercept=0.5, color = "lightgray") +
  geom_point(aes(color = predict_col)) +
  geom_errorbar(aes(xmin = lb, xmax = ub, color = predict_col), height = 0.2, orientation = "y") +
  scale_color_identity() +
  xlab("proportion of even systems") +
  ylab("domain") +
  mytheme +
  scale_x_continuous(limits = c(0,1), labels = c("0", "0.25", "0.5", "0.75", "1")) 

ggsave(here("output", "figures", "results_bayes.pdf"), plot = plot_bayes, height = 8/3)

plot_freq <- plot_bayes  + all_result_freq_forplot
ggsave(here("output", "figures", "results_freq.pdf"), plot = plot_freq, height = 8/3)

plot_phylo <- plot_bayes  + all_result_phylo_forplot
ggsave(here("output", "figures", "results_phylo.pdf"), plot = plot_phylo, height = 8/3)

show(plot_phylo)

all_results %>% 
  kable() %>%  
  kable_styling(full_width = FALSE)

all_results_bayes %>% 
  kable() %>%  
  kable_styling(full_width = FALSE)

all_results_phylo %>% 
  kable() %>%  
  kable_styling(full_width = FALSE)
```

The table for `all_results_bayes` shows warnings for several domains but I haven't addressed this since these results aren't included in the paper.

## Spatial demonstratives

Some of this code uses "relation symmetry" to refer to what is called "orientation symmetry" in the paper.

```{r demonstratives, cache=TRUE}

d <- read_csv(here("data", "nintemann_demonstratives.csv"))

canonical_representation <- function(vec) {
  # Get the unique elements in the order they first appear
  unique_elements <- unique(vec)
  # Create a factor with levels ordered by their appearance
  factor_vec <- factor(vec, levels = unique_elements)
  # Convert the factor to its numeric representation
  canonical_vec <- as.numeric(factor_vec)
  return(canonical_vec)
}

# Generate unique string for a system
system_id <- function(data) {
  data <- data %>%
    arrange(Type, Relation) %>% 
    select(Type, Relation, word_string_type) 
   data$word_string_type <- canonical_representation(data$word_string_type) 
  return( paste(unlist(data), collapse = "|") )
}  

d_ids <- d %>%
  group_by(Language, Region) %>%
  mutate(s_id = system_id(pick(everything()))) %>% 
  ungroup()

d_cnts <- d_ids %>% 
  select(Language, Region, s_id, is_distance_symmetric, is_relation_symmetric) %>%
  unique() %>% 
  group_by(s_id, is_distance_symmetric, is_relation_symmetric) %>% 
  summarize(count = n(), .groups = "drop")  %>% 
  mutate(dlab = if_else(is_distance_symmetric, "D", "")) %>%
  mutate(rlab = if_else(is_relation_symmetric, "O", "")) %>%
  mutate(bothlab = paste0(dlab,rlab)) %>% 
  mutate(bothlab = if_else(bothlab == "DO", " (D,O)", bothlab)) %>%
  mutate(bothlab = if_else(bothlab == "D", " (D)", bothlab)) %>%
  mutate(bothlab = if_else(bothlab == "O", " (O)", bothlab)) %>%
  mutate(label = paste0("n=", count, bothlab)) %>% 
  select(-dlab, -rlab, -bothlab) 

s_sorted <- d_cnts %>% 
  filter(count > 2) %>% 
  arrange(desc(count)) 
  
s_id_order <- s_sorted %>%   
  pull(s_id)

strip_labels <- s_sorted %>%
  pull(label)

label_map <- setNames(strip_labels, s_id_order)

sys_plot_data <- d_ids %>% 
  select(Type, Relation, word_string_type, s_id) %>% 
  group_by(Type, Relation, s_id) %>% 
  summarize(word_string_type = first(word_string_type), .groups = "drop") %>%
  left_join(d_cnts, by = "s_id") %>% 
  filter(count > 2) %>%
  arrange(desc(count), Type, Relation) %>% 
  mutate(s_id = factor(s_id, levels = s_id_order))

sys_plot <- sys_plot_data %>% 
  mutate(word_string_type = as.factor(word_string_type)) %>% 
  ggplot(aes(x = Relation, y = Type, fill = word_string_type)) +
  geom_tile() +
  #scale_fill_brewer(palette = "Set3") +
  scale_fill_brewer(palette = "Paired") +
  facet_wrap(~s_id, ncol = 4, labeller = labeller(s_id= as_labeller(label_map))) +
  mytheme +
  #theme(strip.text = element_blank())+
  theme( strip.background = element_blank()) +
  theme(legend.position = "none")  +
  ylab("Distance Level") + xlab('Orientation')

d_summ <- d %>% 
  select(Language, Region, language_glottolog, family_name, is_distance_symmetric, is_relation_symmetric) %>% 
  unique()

d_plot_distance_symm <- d_summ %>% 
  group_by(is_distance_symmetric)  %>% 
  summarize(count = n()) %>% 
  mutate(symmetry="Distance symmetry") %>% 
  rename(symmetric = is_distance_symmetric) 

d_plot_relation_symm <- d_summ %>% 
  group_by(is_relation_symmetric)  %>% 
  summarize(count = n()) %>% 
  mutate(symmetry="Orientation symmetry") %>% 
  rename(symmetric = is_relation_symmetric) 

summ_plot_data <- bind_rows(d_plot_distance_symm, d_plot_relation_symm) %>% 
  mutate(symmetric = if_else(symmetric, "yes", "no")) %>% 
  mutate(symmetric = factor(symmetric, levels = c("no", "yes"))) 

summ_plot <- summ_plot_data %>% 
  ggplot(aes(x = symmetric, y = count, fill = symmetric, color=symmetric)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("yes" = yes_no_cols[1], "no" = yes_no_cols[2])) +
  scale_color_manual(values = c("yes" = yes_no_cols[1], "no" = yes_no_cols[2])) +
  ylab('system count') + 
  mytheme +
  theme(legend.position = "none") +
  facet_wrap(~symmetry, ncol=1) +
  ylab("Number of languages") +
  xlab("Is system symmetric?")

sd_plot <- sys_plot + summ_plot +
    plot_layout(widths = c(4,1)) +
    plot_annotation(tag_levels = c('a'), tag_suffix = ')')

ggsave(here("output", "figures", "spatial_demonstratives.pdf"), plot = sd_plot, width = 7,height = 4)

show(sd_plot)

sd_stats_data <- d_ids %>% 
  select(id, is_distance_symmetric, is_relation_symmetric) %>% 
  rename(glottocode = id) %>% 
  group_by(glottocode) %>%  
  # two languages (Serbian, Croatian) have the same glottocode. They have isomorphic demonstrative systems, so we can drop either one for statistical analysis
  summarize(is_distance_symmetric = first(is_distance_symmetric), 
                         is_relation_symmetric = first(is_relation_symmetric), .groups = "drop") %>%
  unique() %>% 
  left_join(gl, by = "glottocode")

# code is set up to expect a dependent variable called parity -- so we'll set up variables with this name based on the symmetry variables

sd_stats_data_dist <- sd_stats_data %>% 
  mutate(parity = if_else(is_distance_symmetric, "even", "odd")) 

sd_stats_data_rel <- sd_stats_data %>% 
  mutate(parity = if_else(is_relation_symmetric, "even", "odd")) 

sd_dist_results <- run_glmmTMB(sd_stats_data_dist, "spatial demonstratives (distance)") 
sd_dist_results_bayes <- run_brms(sd_stats_data_dist, "spatial demonstratives (distance)") 
sd_dist_results_phylo <- run_phylo(sd_stats_data_dist, "spatial demonstratives (distance)") 

sd_rel_results <- run_glmmTMB(sd_stats_data_rel, "spatial demonstratives (relation)") 
sd_rel_results_bayes <- run_brms(sd_stats_data_rel, "spatial demonstratives (relation)") 
sd_rel_results_phylo <- run_phylo(sd_stats_data_rel, "spatial demonstratives (relation)") 

```

The proportions of systems with distance symmetry and relation symmetry are `r round(sum(sd_stats_data$is_distance_symmetric) / nrow(sd_stats_data), 2)` and `r round(sum(sd_stats_data$is_relation_symmetric) / nrow(sd_stats_data), 2)`, respectively.


Based on the phylogenetic regressions, the estimate for distance symmetry is `r round(logistic(sd_dist_results_phylo$coefficient),2)` (95% credible interval: `r round(logistic(sd_dist_results_phylo$lb), 2)`, `r round(logistic(sd_dist_results_phylo$ub),2)`) and for relation symmetry is `r round(logistic(sd_rel_results_phylo$coefficient),2)` (95% credible interval: `r round(logistic(sd_rel_results_phylo$lb),2)`, `r round(logistic(sd_rel_results_phylo$ub),2)`). 


## Distributions across areas and language families

Make Tables S1 and S2

```{r summary_tables}
all_stats_data <- bind_rows(
  deictic_stats_data %>% mutate(domain = "deictic day names"),
  tense_stats_data %>% mutate(domain = "tense"),
  seasons_stats_data %>% mutate(domain = "seasons"),
  moonphases_stats_data %>% mutate(domain = "moon phases"),
  locational_stats_group_data, 
  kinship_stats_data ,
  color_stats_data %>% mutate(domain = "color"),
  lifeform_stats_data %>% mutate(domain = "life forms"),
  sd_stats_data %>% mutate(domain = "spatial demonstratives")
)

# I used this part to identify areas that needed to be manually specified
# missing_area <- all_data_table %>% 
#  select(glottocode, glottolog_langname, langfamily, area) %>% 
#  filter(area =="") %>% 
#  unique() %>% 
#  write_csv(here("data", "missing_areas_starter.csv"))
 
missing_area <- read_csv(here("data", "missing_areas.csv")) %>% 
  select(glottocode, area) %>% 
  rename(manual_area = area)

all_data_table <- all_stats_data %>% 
  select(glottocode, domain) %>% 
  left_join(gl, by = "glottocode") %>% 
  filter(!is.na(glottocode)) %>% 
  unique() %>% 
  left_join(missing_area, by = "glottocode") %>% 
  mutate(area = if_else(area=="", manual_area, area)) 

all_data_table_area <- all_data_table %>%
  group_by(domain, area) %>% 
  summarize(count = n(), .groups = "drop") %>% 
  bind_rows(tibble(domain = "social categories", area = "Australia", count = sum(social_counts$count))) %>%  
  mutate(domain = factor(domain, levels = c(domain_order, "spatial demonstratives"))) %>% 
  arrange(domain, desc(count)) 
  
all_data_table_area_wide <- all_data_table_area %>%
  pivot_wider(names_from = area, values_from= count) %>% 
  mutate(across(everything(), ~replace_na(.,0))) %>% 
  select(domain, Africa, Australia, Eurasia, `North America`, Papunesia, `South America`) %>%
  mutate(Total = as.integer(rowSums(across(Africa:`South America`)))) %>% 
  rename(Domain = domain)

all_data_table_family <- all_data_table %>%
  group_by(domain, langfamily) %>% 
  summarize(count = n(), .groups = "drop") %>% 
  group_by(domain) %>% 
  mutate(rank = rank(desc(count), ties.method = "first")) %>%
  ungroup() %>% 
  mutate(domain = factor(domain, levels = c(domain_order, "spatial demonstratives"))) %>% 
  arrange(domain, desc(count)) 

top_families <- all_data_table_family %>% 
  filter(rank <= 5) %>% 
  filter(count >= 2) %>% 
  filter(!str_detect(langfamily, "^[0-9]")) %>% 
  pull(langfamily) %>%
  unique() %>% 
  sort()

top_family_count <- length(top_families)

all_data_table_family <- all_data_table_family %>% 
  mutate(langfamily = if_else(langfamily %in% top_families, langfamily, "Other")) %>% 
  group_by(domain, langfamily) %>% 
  summarize(count = sum(count), .groups = "drop") 

all_data_table_family_wide <- all_data_table_family %>%
  pivot_wider(names_from = langfamily, values_from= count) %>% 
  mutate(across(everything(), ~replace_na(.,0)))  

all_data_table_family_wide_sort <- all_data_table_family_wide %>%
  select(everything(), -Other, Other) %>%
  select(
    1,            # Keep the first column as is
    sort(names(.)[2:top_family_count + 1]), # Sort columns 2 through 20 by name
    everything() # Put the remaining columns (including "Other") at the end
  ) %>% 
  mutate(Total =  as.integer(rowSums(select(., -1)))) %>% 
  rename(Domain = domain)

all_data_table_area_wide %>% 
  kable() %>%  
  kable_styling(full_width = FALSE)

latex_table_area <- xtable(all_data_table_area_wide)
print(latex_table_area, file = here("output", "tables", "data_area_table.tex"), include.rownames=FALSE)

all_data_table_family_wide_sort %>% 
  kable() %>%  
  kable_styling(full_width = FALSE)

rotated_colnames <- paste0("\\rotatebox{90}{", names(all_data_table_family_wide_sort), "}")
rotated_colnames[1] <- "Domain"
names(all_data_table_family_wide_sort) <- rotated_colnames

latex_table_family <- xtable(all_data_table_family_wide_sort)
print(latex_table_family, file = here("output", "tables", "data_family_table.tex"), include.rownames=FALSE, sanitize.colnames.function = function(x){x})
```
